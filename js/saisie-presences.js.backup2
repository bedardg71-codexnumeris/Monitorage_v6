/* ===============================
   MODULE: SAISIE DES PR√âSENCES
   Version refond√©e compl√®te avec toutes les fonctionnalit√©s
   
   ‚ö†Ô∏è ARCHITECTURE ‚ö†Ô∏è
   Ce module LIT les donn√©es depuis :
   - trimestre.js : obtenirCalendrierComplet()
   - horaire.js : obtenirSeancesJour(dateStr)
   
   Il ne doit JAMAIS recalculer les dates ou s√©ances.
   =============================== */

/* ===============================
   üöÄ INITIALISATION DU MODULE
   =============================== */

/**
 * Initialise le module de saisie des pr√©sences
 * Appel√©e par main.js au chargement
 */
/* ===============================
   CALCUL DES INDICES D'ASSIDUIT√â
   =============================== */

/**
 * Fonction orchestratrice : Calcule et sauvegarde les deux indices
 * Appel√©e apr√®s chaque enregistrement de pr√©sences
 */
function calculerEtSauvegarderIndicesAssiduite() {
    console.log('Calcul des indices d\'assiduit√©...');

    // IMPORTANT : Utiliser obtenirDonneesSelonMode pour respecter le mode actuel
    const etudiants = obtenirDonneesSelonMode('groupeEtudiants');

    // Structure de sortie
    const indices = {
        sommatif: {},
        alternatif: {},
        dateCalcul: new Date().toISOString()
    };

    // Filtrer les √©tudiants actifs
    const etudiantsActifs = etudiants.filter(e =>
        e.statut !== 'd√©crochage' && e.statut !== 'abandon'
    );

    // Calculer pour chaque √©tudiant
    etudiantsActifs.forEach(etudiant => {
        indices.sommatif[etudiant.da] = calculerAssiduiteSommative(etudiant.da);
        indices.alternatif[etudiant.da] = calculerAssiduiteAlternative(etudiant.da);
    });

    // Sauvegarder
    // IMPORTANT : Utiliser sauvegarderDonneesSelonMode pour respecter le mode actuel
    sauvegarderDonneesSelonMode('indicesAssiduite', indices);

    console.log('‚úÖ Indices d\'assiduit√© sauvegard√©s');
    console.log('   Sommatif:', Object.keys(indices.sommatif).length, '√©tudiants');
    console.log('   Alternatif:', Object.keys(indices.alternatif).length, '√©tudiants');

    return indices;
}

/**
 * Calcule l'assiduit√© SOMMATIVE (depuis le d√©but du trimestre)
 * Formule : Total heures pr√©sentes √∑ Total heures DONN√âES (pas th√©oriques)
 *
 * IMPORTANT : Les s√©ances facultatives (interventions R√†I) ne p√©nalisent PAS l'assiduit√©.
 * - S√©ance facultative o√π l'√©tudiant est PR√âSENT : compte au num√©rateur ET au d√©nominateur
 * - S√©ance facultative o√π l'√©tudiant est ABSENT : ne compte NI au num√©rateur NI au d√©nominateur
 *
 * @param {string} da - Num√©ro DA de l'√©tudiant
 * @returns {Object} - { indice, heuresPresentes, heuresOffertes, nombreSeances }
 */
function calculerAssiduiteSommative(da) {
    // IMPORTANT : Utiliser obtenirDonneesSelonMode pour respecter le mode actuel
    const presences = obtenirDonneesSelonMode('presences') || [];

    // Obtenir toutes les DATES o√π des pr√©sences ont √©t√© saisies
    const datesSaisies = [...new Set(presences.map(p => p.date))].sort();

    if (datesSaisies.length === 0) {
        console.warn('‚ö†Ô∏è Aucune pr√©sence saisie');
        return {
            indice: 1,
            heuresPresentes: 0,
            heuresOffertes: 0,
            nombreSeances: 0
        };
    }

    // Obtenir les pr√©sences de cet √©tudiant
    const presencesEtudiant = presences.filter(p => p.da === da);

    // Calculer le total d'heures DONN√âES pour cet √©tudiant
    // = nombre de s√©ances (excluant les s√©ances facultatives o√π l'√©tudiant √©tait absent) √ó 2h
    let totalHeuresDonnees = 0;
    let totalHeuresPresentes = 0;

    // Compter les s√©ances NON facultatives pour l'affichage
    const seancesNonFacultatives = new Set();

    datesSaisies.forEach(date => {
        // Trouver la pr√©sence de l'√©tudiant pour cette date
        const presenceDate = presencesEtudiant.find(p => p.date === date);

        if (presenceDate) {
            // L'√©tudiant a une entr√©e pour cette date
            const estFacultatif = presenceDate.facultatif === true;
            const heuresPresence = presenceDate.heures || 0;

            if (estFacultatif && heuresPresence === 0) {
                // S√©ance facultative o√π l'√©tudiant √©tait absent
                // Ne compte ni au num√©rateur ni au d√©nominateur
                console.log(`   ‚ö™ ${date}: S√©ance facultative (absent) - non comptabilis√©e`);
            } else if (estFacultatif && heuresPresence > 0) {
                // S√©ance facultative o√π l'√©tudiant √©tait PR√âSENT
                // Utiliser la dur√©e R√âELLE de l'intervention (pas 2h fixes)
                totalHeuresDonnees += heuresPresence;
                totalHeuresPresentes += heuresPresence;
                console.log(`   ‚úÖ ${date}: Intervention R√†I (${heuresPresence}h) - ${heuresPresence}h/${heuresPresence}h comptabilis√©es`);
            } else {
                // S√©ance normale (2h standard)
                // Compter comme s√©ance non facultative
                seancesNonFacultatives.add(date);

                // CORRECTIF : Si heuresPresence > 2h (ex: cours + intervention R√†I),
                // ajuster le d√©nominateur pour √©viter les pourcentages > 100%
                const heuresCours = 2;
                if (heuresPresence > heuresCours) {
                    // Les heures suppl√©mentaires sont des interventions R√†I
                    // Ajouter au num√©rateur ET au d√©nominateur
                    totalHeuresDonnees += heuresPresence;
                    totalHeuresPresentes += heuresPresence;
                } else {
                    // Cas normal : <= 2h
                    totalHeuresDonnees += heuresCours;
                    totalHeuresPresentes += heuresPresence;
                }
            }
        } else {
            // L'√©tudiant n'a pas d'entr√©e pour cette date
            // V√©rifier si cette date correspond √† une s√©ance facultative (intervention R√†I)
            const presencesDate = presences.filter(p => p.date === date);
            const estSeanceFacultative = presencesDate.length > 0 &&
                                         presencesDate.every(p => p.facultatif === true);

            if (!estSeanceFacultative) {
                // S√©ance normale obligatoire : compte au d√©nominateur (0 au num√©rateur)
                seancesNonFacultatives.add(date);
                totalHeuresDonnees += 2;
            }
            // Si s√©ance facultative : on ne fait rien (ni num√©rateur ni d√©nominateur)
        }
    });

    if (totalHeuresDonnees === 0) {
        console.warn(`‚ö†Ô∏è Aucune heure donn√©e pour ${da}`);
        return {
            indice: 1,
            heuresPresentes: 0,
            heuresOffertes: 0,
            nombreSeances: 0
        };
    }

    const indice = totalHeuresPresentes / totalHeuresDonnees;

    console.log(`   Sommatif ${da}: ${totalHeuresPresentes}h / ${totalHeuresDonnees}h = ${(indice * 100).toFixed(1)}%`);

    // Retourner un objet avec tous les d√©tails (Single Source of Truth)
    return {
        indice: Math.min(indice, 1),
        heuresPresentes: totalHeuresPresentes,
        heuresOffertes: totalHeuresDonnees,
        nombreSeances: seancesNonFacultatives.size
    };
}

/**
 * Calcule l'assiduit√© ALTERNATIVE (sur les N derni√®res s√©ances)
 * Formule : Heures pr√©sentes sur N derni√®res s√©ances √∑ heures donn√©es (excluant facultatif absent)
 *
 * IMPORTANT : Les s√©ances facultatives (interventions R√†I) ne p√©nalisent PAS l'assiduit√©.
 * - S√©ance facultative o√π l'√©tudiant est PR√âSENT : compte au num√©rateur ET au d√©nominateur
 * - S√©ance facultative o√π l'√©tudiant est ABSENT : ne compte NI au num√©rateur NI au d√©nominateur
 *
 * Le nombre de s√©ances est param√©trable via les r√©glages de notation.
 * Par d√©faut : 6 s√©ances (= 3 cours = 12h)
 *
 * @param {string} da - Num√©ro DA de l'√©tudiant
 * @returns {number} - Indice entre 0 et 1
 */
function calculerAssiduiteAlternative(da) {
    // IMPORTANT : Utiliser obtenirDonneesSelonMode pour respecter le mode actuel
    const presences = obtenirDonneesSelonMode('presences') || [];

    // Obtenir le nombre de s√©ances depuis les r√©glages
    const config = JSON.parse(localStorage.getItem('modalitesEvaluation') || '{}');
    const nombreCours = config.configPAN?.nombreCours || 3; // Par d√©faut 3 cours
    const nombreSeances = nombreCours * 2; // 3 cours = 6 s√©ances

    console.log(`   Calcul alternatif : ${nombreCours} derniers cours = ${nombreSeances} s√©ances`);

    // Obtenir toutes les dates o√π des pr√©sences ont √©t√© saisies (ordre chronologique)
    const datesSaisies = [...new Set(presences.map(p => p.date))].sort();

    if (datesSaisies.length === 0) {
        console.log(`   Alternatif ${da}: Aucune saisie, retour 100%`);
        return 1; // Pas encore de saisie
    }

    // Prendre les N derni√®res dates de saisie
    const dernieresDates = datesSaisies.slice(-nombreSeances);

    console.log(`   Derni√®res dates pour ${da}:`, dernieresDates);

    // Obtenir les pr√©sences de cet √©tudiant
    const presencesEtudiant = presences.filter(p =>
        p.da === da && dernieresDates.includes(p.date)
    );

    // Calculer en tenant compte des s√©ances facultatives
    let totalHeuresDonnees = 0;
    let totalHeuresPresentes = 0;

    dernieresDates.forEach(date => {
        const presenceDate = presencesEtudiant.find(p => p.date === date);

        if (presenceDate) {
            const estFacultatif = presenceDate.facultatif === true;
            const heuresPresence = presenceDate.heures || 0;

            if (estFacultatif && heuresPresence === 0) {
                // S√©ance facultative o√π l'√©tudiant √©tait absent
                // Ne compte ni au num√©rateur ni au d√©nominateur
                console.log(`   ‚ö™ ${date}: S√©ance facultative (absent) - non comptabilis√©e`);
            } else if (estFacultatif && heuresPresence > 0) {
                // S√©ance facultative o√π l'√©tudiant √©tait PR√âSENT
                // Utiliser la dur√©e R√âELLE de l'intervention (pas 2h fixes)
                totalHeuresDonnees += heuresPresence;
                totalHeuresPresentes += heuresPresence;
            } else {
                // S√©ance normale (2h standard)
                // CORRECTIF : Si heuresPresence > 2h (ex: cours + intervention R√†I),
                // ajuster le d√©nominateur pour √©viter les pourcentages > 100%
                const heuresCours = 2;
                if (heuresPresence > heuresCours) {
                    // Les heures suppl√©mentaires sont des interventions R√†I
                    // Ajouter au num√©rateur ET au d√©nominateur
                    totalHeuresDonnees += heuresPresence;
                    totalHeuresPresentes += heuresPresence;
                } else {
                    // Cas normal : <= 2h
                    totalHeuresDonnees += heuresCours;
                    totalHeuresPresentes += heuresPresence;
                }
            }
        } else {
            // L'√©tudiant n'a pas d'entr√©e pour cette date
            // V√©rifier si cette date correspond √† une s√©ance facultative (intervention R√†I)
            const presencesDate = presences.filter(p => p.date === date);
            const estSeanceFacultative = presencesDate.length > 0 &&
                                         presencesDate.every(p => p.facultatif === true);

            if (!estSeanceFacultative) {
                // S√©ance normale obligatoire : compte au d√©nominateur (0 au num√©rateur)
                totalHeuresDonnees += 2;
            }
            // Si s√©ance facultative : on ne fait rien (ni num√©rateur ni d√©nominateur)
        }
    });

    if (totalHeuresDonnees === 0) {
        console.warn(`   ‚ö†Ô∏è Aucune heure donn√©e pour ${da} (alternatif)`);
        return 1; // Par d√©faut 100%
    }

    const indice = totalHeuresPresentes / totalHeuresDonnees;

    console.log(`   Alternatif ${da}: ${totalHeuresPresentes}h / ${totalHeuresDonnees}h = ${(indice * 100).toFixed(1)}%`);

    // Retourner l'indice (entre 0 et 1, plafonn√© √† 1)
    return Math.min(indice, 1);
}

/**
 * Fonction utilitaire : Obtenir la configuration de notation
 * Utilis√©e par d'autres modules pour lire les param√®tres PAN
 * 
 * @returns {Object} Configuration compl√®te de notation
 */
function obtenirConfigurationNotation() {
    return JSON.parse(localStorage.getItem('modalitesEvaluation') || '{}');
}

function initialiserModuleSaisiePresences() {
    console.log('‚ö° Initialisation du module Saisie des Pr√©sences');

    const sectionSaisie = document.getElementById('presences-saisie');
    if (!sectionSaisie) {
        console.log('‚ö†Ô∏è Section saisie non active, initialisation report√©e');
        return;
    }

    chargerGroupesPresences();
    verifierConfigurationFormatHoraire();

    const dateInput = document.getElementById('date-cours');
    if (dateInput && dateInput.value) {
        initialiserSaisiePresences();
        calculerEtSauvegarderIndicesAssiduite();

        console.log('‚úÖ Module Saisie des Pr√©sences initialis√©');
    }
}

/* ===============================
   GESTION DES GROUPES
   =============================== */

/**
 * Charge la liste des groupes dans le select
 */
function chargerGroupesPresences() {
    const selectGroupe = document.getElementById('selectGroupePresences');
    if (!selectGroupe) {
        console.log('‚ö†Ô∏è Element selectGroupePresences non trouv√©');
        return;
    }

    // Obtenir les √©tudiants selon le mode actif
    // IMPORTANT : Utiliser obtenirDonneesSelonMode pour respecter le mode actuel
    const etudiants = obtenirDonneesSelonMode('groupeEtudiants') || [];

    // Extraire les groupes uniques
    const groupesSet = new Set();
    etudiants.forEach(e => {
        if (e.groupe && e.groupe.trim() !== '') {
            groupesSet.add(e.groupe);
        }
    });

    const groupes = Array.from(groupesSet).sort();

    // Remplir le select
    selectGroupe.innerHTML = '<option value="">Tous les groupes</option>';
    groupes.forEach(groupe => {
        const option = document.createElement('option');
        option.value = groupe;
        option.textContent = groupe;
        selectGroupe.appendChild(option);
    });

    console.log(`‚úÖ ${groupes.length} groupes charg√©s dans le select`);
    calculerEtSauvegarderIndicesAssiduite();
}

/* ===============================
   FONCTIONS DE CALENDRIER
   Utilisent les sources uniques

   NOTE: obtenirDonneesSelonMode() est fournie par modes.js (fonction globale)
   Ne PAS red√©finir localement pour √©viter les conflits!
   =============================== */

/**
 * Obtient les informations d'un jour depuis le calendrier
 */
function obtenirInfosJourCalendrier(dateStr) {
    // V√©rifier d'abord si les fonctions existent
    if (typeof obtenirInfosJour === 'function') {
        return obtenirInfosJour(dateStr);
    }

    if (typeof obtenirCalendrierComplet === 'function') {
        const calendrier = obtenirCalendrierComplet();
        return calendrier ? calendrier[dateStr] : null;
    }

    // Fallback : lire directement depuis localStorage
    console.warn('‚ö†Ô∏è Fonctions trimestre.js non disponibles, lecture directe');
    const calendrier = JSON.parse(localStorage.getItem('calendrierComplet') || '{}');
    return calendrier[dateStr] || null;
}

/**
 * V√©rifie si une date est un jour de cours r√©el
 */
function estJourDeCoursReel(dateStr) {
    // V√©rifier si la fonction existe
    if (typeof obtenirCalendrierComplet === 'function') {
        const calendrier = obtenirCalendrierComplet();
        if (!calendrier || !calendrier[dateStr]) {
            return false;
        }
        const jour = calendrier[dateStr];
        return jour.statut === 'cours' || jour.statut === 'reprise';
    }

    // Fallback : lire directement
    console.warn('‚ö†Ô∏è obtenirCalendrierComplet non disponible, lecture directe');
    const calendrier = JSON.parse(localStorage.getItem('calendrierComplet') || '{}');

    if (!calendrier[dateStr]) {
        return false;
    }

    const jour = calendrier[dateStr];
    return jour.statut === 'cours' || jour.statut === 'reprise';
}

/**
 * Obtient toutes les dates de cours du trimestre
 * VERSION CORRIG√âE : Ne retourne que les jours avec des s√©ances r√©elles
 */
function obtenirToutesDatesCours() {
    // Option 1: Utiliser seancesCompletes (jours avec s√©ances uniquement)
    let seancesCompletes;

    if (typeof obtenirSeancesCompletes === 'function') {
        seancesCompletes = obtenirSeancesCompletes();
    } else {
        console.warn('‚ö†Ô∏è obtenirSeancesCompletes non disponible, lecture directe');
        seancesCompletes = JSON.parse(localStorage.getItem('seancesCompletes') || '{}');
    }

    // Si on a des s√©ances, utiliser ces dates
    if (seancesCompletes && Object.keys(seancesCompletes).length > 0) {
        const datesAvecSeances = Object.keys(seancesCompletes).filter(date => {
            const seances = seancesCompletes[date];
            return seances && seances.length > 0;
        });

        datesAvecSeances.sort();
        console.log(`‚úÖ ${datesAvecSeances.length} dates avec s√©ances trouv√©es`);

        if (datesAvecSeances.length > 0) {
            console.log('Exemples:', datesAvecSeances.slice(0, 5));
            return datesAvecSeances;
        }
    }

    // Option 2: Fallback - utiliser calendrierComplet mais filtrer par jour de semaine
    console.warn('‚ö†Ô∏è Pas de s√©ances compl√®tes, utilisation du calendrier avec filtrage');

    let calendrier;
    if (typeof obtenirCalendrierComplet === 'function') {
        calendrier = obtenirCalendrierComplet();
    } else {
        calendrier = JSON.parse(localStorage.getItem('calendrierComplet') || '{}');
    }

    if (!calendrier || Object.keys(calendrier).length === 0) {
        console.error('‚ùå Calendrier vide');
        return [];
    }

    // Obtenir les jours de s√©ances depuis l'horaire
    const seancesHoraire = JSON.parse(localStorage.getItem('seancesHoraire') || '[]');
    const joursAvecSeances = new Set();
    seancesHoraire.forEach(seance => {
        if (seance.jour) {
            joursAvecSeances.add(seance.jour);
        }
    });

    console.log('Jours configur√©s dans l\'horaire:', Array.from(joursAvecSeances));

    // Filtrer pour ne garder que les jours qui correspondent √† l'horaire
    const datesCours = [];
    Object.keys(calendrier).forEach(date => {
        const jour = calendrier[date];
        if (jour && jour.statut) {
            // Cours normal : v√©rifier si c'est un jour de l'horaire
            if (jour.statut === 'cours' && joursAvecSeances.has(jour.jourSemaine)) {
                datesCours.push(date);
            }
            // Reprise : toujours inclure (utilise jourRemplace)
            else if (jour.statut === 'reprise') {
                datesCours.push(date);
            }
        }
    });

    datesCours.sort();
    console.log(`‚úÖ ${datesCours.length} dates de cours filtr√©es (jours avec s√©ances)`);

    return datesCours;
}

/* ===============================
   üïê FONCTIONS DE S√âANCES
   =============================== */

/**
 * Obtient les heures totales d'une s√©ance pour une date
 */
function obtenirHeuresSeance(dateStr) {
    let seances;

    // Essayer d'abord la fonction du module
    if (typeof obtenirSeancesJour === 'function') {
        seances = obtenirSeancesJour(dateStr);
    } else {
        // Fallback : lecture directe
        const seancesCompletes = JSON.parse(localStorage.getItem('seancesCompletes') || '{}');
        seances = seancesCompletes[dateStr] || [];
    }

    console.log(`üìö S√©ances pour ${dateStr}:`, seances);

    if (!seances || seances.length === 0) {
        // Pour les jours de cours sans s√©ances d√©finies, utiliser valeur par d√©faut
        const infoJour = obtenirInfosJourCalendrier(dateStr);
        if (infoJour && (infoJour.statut === 'cours' || infoJour.statut === 'reprise')) {
            const formatHoraire = localStorage.getItem('formatHoraire');
            const heuresDefaut = formatHoraire === '1x4' ? 4 : 2;
            console.log(`‚ö†Ô∏è Pas de s√©ances d√©finies pour ce jour de cours, utilisation de ${heuresDefaut}h par d√©faut`);
            return heuresDefaut;
        }
        return 0;
    }

    let totalHeures = 0;
    seances.forEach(seance => {
        // G√©rer diff√©rents formats de s√©ance
        // Format nouveau (avec propri√©t√©s debut/fin)
        if (seance.debut && seance.fin) {
            const debut = seance.debut.split(':');
            const fin = seance.fin.split(':');

            const heureDebut = parseInt(debut[0]) + parseInt(debut[1]) / 60;
            const heureFin = parseInt(fin[0]) + parseInt(fin[1]) / 60;

            totalHeures += (heureFin - heureDebut);
        }
        // Format ancien (avec heureDebut/heureFin) 
        else if (seance.heureDebut && seance.heureFin) {
            const debut = seance.heureDebut.split(':');
            const fin = seance.heureFin.split(':');

            const heureDebut = parseInt(debut[0]) + parseInt(debut[1]) / 60;
            const heureFin = parseInt(fin[0]) + parseInt(fin[1]) / 60;

            totalHeures += (heureFin - heureDebut);
        }
        // Si format inconnu mais jour de cours valide
        else {
            console.warn('‚ö†Ô∏è Format de s√©ance non reconnu:', seance);
            // Utiliser une valeur par d√©faut
            const formatHoraire = localStorage.getItem('formatHoraire');
            totalHeures = formatHoraire === '1x4' ? 4 : 2;
        }
    });

    return 2;  // Simplification : toujours 2h par s√©ance
}

/**
 * Formate les heures pour l'affichage
 */
function formaterHeuresAffichage(heures) {
    if (!heures || heures === 0) return '';

    const heuresInt = Math.floor(heures);
    const minutes = Math.round((heures - heuresInt) * 60);

    if (minutes === 0) {
        return `${heuresInt}h`;
    } else {
        return `${heuresInt}h${minutes.toString().padStart(2, '0')}`;
    }
}

/**
 * Calcule le nombre de s√©ances jusqu'√† une date
 */
function calculerNombreSeances(dateJusqua) {
    let seances;

    // Essayer d'abord la fonction du module
    if (typeof obtenirSeancesCompletes === 'function') {
        seances = obtenirSeancesCompletes();
    } else {
        // Fallback : lecture directe
        console.warn('‚ö†Ô∏è obtenirSeancesCompletes non disponible, lecture directe');
        seances = JSON.parse(localStorage.getItem('seancesCompletes') || '{}');
    }

    if (!seances || Object.keys(seances).length === 0) {
        console.warn('‚ö†Ô∏è Pas de s√©ances disponibles');
        return 0;
    }

    let compteur = 0;
    Object.keys(seances).forEach(date => {
        if (date <= dateJusqua && seances[date] && seances[date].length > 0) {
            compteur++;
        }
    });

    return compteur;
}

/**
 * Obtient la dur√©e maximale d'une s√©ance
 */
function obtenirDureeMaxSeance() {
    // Simplification p√©dagogique : toujours 2h max par s√©ance
    // (2 p√©riodes de 60 minutes = 2 heures)
    return 2;
}

/* ===============================
   üîç VALIDATION ET V√âRIFICATION
   =============================== */

/**
 * Valide si une date peut √™tre saisie
 */
function validerDateSaisie(dateStr) {
    if (!dateStr) {
        return { valide: false, raison: 'vide', verrouille: false };
    }

    const infoJour = obtenirInfosJourCalendrier(dateStr);

    if (!infoJour) {
        return { valide: false, raison: 'hors-calendrier', verrouille: false };
    }

    // V√©rifier le statut - accepter cours ET reprise
    if (infoJour.statut !== 'cours' && infoJour.statut !== 'reprise') {
        return { valide: false, raison: 'pas-cours', verrouille: false };
    }

    // V√©rifier si c'est un jour o√π il y a des s√©ances
    const heuresSeance = obtenirHeuresSeance(dateStr);
    if (heuresSeance === 0) {
        console.warn(`‚ö†Ô∏è Jour de cours sans s√©ances: ${dateStr}`);
        // On accepte quand m√™me pour permettre la saisie manuelle
    }

    const dateSelectionnee = new Date(dateStr + 'T00:00:00');
    const aujourdhui = new Date();
    aujourdhui.setHours(0, 0, 0, 0);

    if (dateSelectionnee > aujourdhui) {
        return { valide: false, raison: 'future', verrouille: false };
    }

    const verrouille = estDateVerrouillee(dateStr);

    return {
        valide: true,
        raison: '',
        verrouille: verrouille
    };
}

/**
 * V√©rifie si une date est verrouill√©e
 */
function estDateVerrouillee(dateStr) {
    const datesVerrouillees = JSON.parse(localStorage.getItem('datesVerrouillees') || '[]');
    return datesVerrouillees.includes(dateStr);
}

/**
 * Bascule le verrouillage d'une date
 */
function basculerVerrouillageDate(dateStr) {
    let datesVerrouillees = JSON.parse(localStorage.getItem('datesVerrouillees') || '[]');

    const index = datesVerrouillees.indexOf(dateStr);
    if (index > -1) {
        datesVerrouillees.splice(index, 1);
        console.log('üîì Date d√©verrouill√©e:', dateStr);
    } else {
        datesVerrouillees.push(dateStr);
        console.log('üîí Date verrouill√©e:', dateStr);
    }

    localStorage.setItem('datesVerrouillees', JSON.stringify(datesVerrouillees));
    initialiserSaisiePresences();
}

/**
 * V√©rifie la configuration du format horaire
 */
function verifierConfigurationFormatHoraire() {
    const alerteDiv = document.getElementById('alerteFormatHoraire');
    if (!alerteDiv) return;

    const formatHoraire = localStorage.getItem('formatHoraire');
    const seancesHoraire = JSON.parse(localStorage.getItem('seancesHoraire') || '[]');

    if (!formatHoraire || seancesHoraire.length === 0) {
        alerteDiv.style.display = 'block';
        alerteDiv.innerHTML = `
            <div class="alerte alerte-avertissement">
                <strong>‚ö†Ô∏è Configuration incompl√®te</strong><br>
                L'horaire des cours n'est pas configur√©. 
                <a href="#" onclick="afficherSection('reglages'); afficherSousSection('reglages-horaire'); return false;">
                    Configurer l'horaire ‚Üí
                </a>
            </div>`;
    } else {
        alerteDiv.style.display = 'none';
    }
}

/* ===============================
   üìù INTERFACE DE SAISIE
   =============================== */

/**
 * Initialise la saisie des pr√©sences pour la date s√©lectionn√©e
 */
function initialiserSaisiePresences() {
    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) {
        const tbody = document.getElementById('tbody-saisie-presences');
        if (tbody) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align: center;">S√©lectionnez une date</td></tr>';
        }
        return;
    }

    const validation = validerDateSaisie(dateInput.value);

    if (!validation.valide) {
        let message = '';
        switch (validation.raison) {
            case 'vide':
                message = 'Veuillez s√©lectionner une date';
                break;
            case 'pas-cours':
                message = 'Ce jour n\'est pas un jour de cours';
                break;
            case 'future':
                message = 'Cette date est dans le futur';
                break;
            case 'hors-calendrier':
                message = 'Cette date est hors du calendrier scolaire';
                break;
            default:
                message = 'Date invalide';
        }

        const tbody = document.getElementById('tbody-saisie-presences');
        if (tbody) {
            tbody.innerHTML = `<tr><td colspan="8" style="text-align: center; color: var(--rouge-erreur);">${message}</td></tr>`;
        }

        mettreAJourEnteteDateSeance('');
        return;
    }

    mettreAJourEnteteDateSeance(dateInput.value);
    chargerTableauPresences(dateInput.value, validation.verrouille);
    mettreAJourBoutonsNavigation();

    // Restaurer la valeur de recherche sauvegard√©e (persistance lors de la navigation)
    const recherche = document.getElementById('recherche-saisie-presences');
    const termeRecherche = localStorage.getItem('recherchePresences') || '';
    if (recherche && termeRecherche) {
        recherche.value = termeRecherche;
        filtrerTableauPresences();
    }
}

/**
 * Met √† jour l'en-t√™te de la saisie avec tous les √©tats visuels
 */
// Note: obtenirRangSeanceDansSemaine() est maintenant d√©finie dans horaire.js (source unique)
// et export√©e globalement via window.obtenirRangSeanceDansSemaine

function mettreAJourEnteteDateSeance(dateStr) {
    const entete = document.getElementById('enteteDateSeance');
    const texte = document.getElementById('texteDateSeance');

    if (!entete || !texte) return;

    if (!dateStr) {
        entete.style.display = 'none';
        return;
    }

    const infoJour = obtenirInfosJourCalendrier(dateStr);

    if (!infoJour) {
        entete.style.display = 'none';
        return;
    }

    const dateFr = formaterDateFrancais(dateStr);
    const heures = obtenirHeuresSeance(dateStr);
    const heuresFormatees = formaterHeuresAffichage(heures);
    const estVerrouille = estDateVerrouillee(dateStr);
    const rangSeance = obtenirRangSeanceDansSemaine(dateStr);

    // R√©cup√©rer le groupe depuis seancesCompletes
    const seancesCompletes = JSON.parse(localStorage.getItem('seancesCompletes') || '{}');
    const seancesDuJour = seancesCompletes[dateStr];
    let groupePrefix = '';
    if (seancesDuJour && seancesDuJour.length > 0 && seancesDuJour[0].groupe) {
        groupePrefix = `Groupe ${seancesDuJour[0].groupe} : `;
    }

    // Retirer toutes les classes d'√©tat
    entete.classList.remove('etat-erreur', 'etat-valide', 'etat-verrouille');

    let message = '';

    if (infoJour.statut === 'cours') {
        message = `${groupePrefix}Pr√©sences au cours du ${dateFr}`;

        // Ajouter le rang de la s√©ance
        if (rangSeance && infoJour.numeroSemaine) {
            message += ` - ${rangSeance.ordinal} s√©ance de la semaine ${infoJour.numeroSemaine}`;
        } else if (infoJour.numeroSemaine) {
            message += ` - Semaine ${infoJour.numeroSemaine}`;
        }

        if (heuresFormatees) {
            message += ` (${heuresFormatees})`;
        }

        entete.classList.add(estVerrouille ? 'etat-verrouille' : 'etat-valide');

    } else if (infoJour.statut === 'reprise') {
        message = `${groupePrefix}Pr√©sences au cours du ${dateFr} - REPRISE`;

        // Ajouter le rang de la s√©ance
        if (rangSeance && infoJour.numeroSemaine) {
            message += ` - ${rangSeance.ordinal} s√©ance de la semaine ${infoJour.numeroSemaine}`;
        }

        if (infoJour.jourRemplace) {
            message += ` (horaire du ${infoJour.jourRemplace.toLowerCase()})`;
        }

        if (heuresFormatees) {
            message += ` - ${heuresFormatees}`;
        }

        entete.classList.add(estVerrouille ? 'etat-verrouille' : 'etat-valide');

    } else if (infoJour.statut === 'conge') {
        message = `${dateFr} - CONG√â`;
        if (infoJour.motif) {
            message += ` (${infoJour.motif})`;
        }
        entete.classList.add('etat-erreur');
        entete.style.display = 'block';
        texte.innerHTML = message;
        return;
    }

    // Ajouter le contr√¥le de verrouillage pour les jours de cours/reprise
    if (infoJour.statut === 'cours' || infoJour.statut === 'reprise') {
        const controleVerrou = `
            <span class="controle-verrouillage">
                <input type="checkbox"
                       id="checkbox-verrouillage-${dateStr}"
                       ${estVerrouille ? 'checked' : ''}
                       onchange="basculerVerrouillageDate('${dateStr}')">
                <label for="checkbox-verrouillage-${dateStr}">
                    <span class="icone-cadenas">${estVerrouille ? 'üîí' : 'üîì'}</span>
                    ${estVerrouille ? 'Verrouill√©e' : 'D√©verrouill√©e'}
                </label>
            </span>`;
        message += controleVerrou;
    }

    entete.style.display = 'block';
    texte.innerHTML = message;
}

/**
 * Charge et affiche le tableau des pr√©sences avec toutes les fonctionnalit√©s
 */
function chargerTableauPresences(dateStr, estVerrouille) {
    const tbody = document.getElementById('tbody-saisie-presences');
    const selectGroupe = document.getElementById('selectGroupePresences');
    const groupeFiltre = selectGroupe ? selectGroupe.value : '';

    const etudiants = obtenirDonneesSelonMode('groupeEtudiants');
    const presences = JSON.parse(localStorage.getItem('presences') || '[]');

    let etudiantsFiltres = etudiants;

    // √âTAPE 1 : Filtrer par groupe (si un groupe est s√©lectionn√©)
    if (groupeFiltre) {
        etudiantsFiltres = etudiants.filter(e => e.groupe === groupeFiltre);
    }

    // √âTAPE 2 : Trier selon le crit√®re choisi
    const selectTri = document.getElementById('selectTriPresences');
    const criterieTri = selectTri ? selectTri.value : 'nom';

    if (criterieTri === 'nom') {
        // Tri alphab√©tique par nom de famille
        etudiantsFiltres.sort((a, b) => {
            const nomA = `${a.nom} ${a.prenom}`.toLowerCase();
            const nomB = `${b.nom} ${b.prenom}`.toLowerCase();
            return nomA.localeCompare(nomB);
        });
    } else if (criterieTri === 'assiduite-croissant') {
        // Tri par assiduit√© croissante (plus faible d'abord)
        etudiantsFiltres.sort((a, b) => {
            const tauxA = calculerTauxAssiduite(a.da, dateStr, 0);
            const tauxB = calculerTauxAssiduite(b.da, dateStr, 0);
            return tauxA - tauxB;
        });
    } else if (criterieTri === 'assiduite-decroissant') {
        // Tri par assiduit√© d√©croissante (plus √©lev√© d'abord)
        etudiantsFiltres.sort((a, b) => {
            const tauxA = calculerTauxAssiduite(a.da, dateStr, 0);
            const tauxB = calculerTauxAssiduite(b.da, dateStr, 0);
            return tauxB - tauxA;
        });
    }

    const dureeSeance = obtenirHeuresSeance(dateStr);

    tbody.innerHTML = '';

    etudiantsFiltres.forEach((etudiant, index) => {
        const presenceExistante = presences.find(p =>
            p.date === dateStr && p.da === etudiant.da
        );

        const heuresPresence = presenceExistante ? (presenceExistante.heures || 0) : dureeSeance;
        const notes = presenceExistante ? (presenceExistante.notes || '') : '';
        const estFacultatif = presenceExistante ? (presenceExistante.facultatif === true) : false;

        const heuresHistorique = calculerTotalHeuresPresence(etudiant.da, dateStr);
        const tauxAssiduiteActuel = calculerTauxAssiduite(
            etudiant.da,
            dateStr,
            parseFloat(heuresPresence) || 0
        );

        const tr = document.createElement('tr');

        // Cr√©er l'input des heures avec les bonnes classes CSS
        const inputHeuresHTML = `
            <input type="number"
                   class="controle-form input-heures ${obtenirClasseSaisie(heuresPresence, dureeSeance, estFacultatif)}"
                   id="heures_${etudiant.da}"
                   value="${heuresPresence}"
                   min="0"
                   max="${dureeSeance}"
                   step="0.5"
                   ${estVerrouille ? 'disabled' : ''}
                   onchange="mettreAJourLigne('${etudiant.da}', '${dateStr}')"
                   oninput="appliquerCodeCouleurSaisie(this, ${dureeSeance})">`;

        // Calculer le total incluant la s√©ance actuelle
        const totalHeuresAvecSeanceActuelle = heuresHistorique + parseFloat(heuresPresence);

        // Structure : DA | Pr√©nom | Nom | Pr√©sence | Notes | Total heures | Assiduit√©
        tr.innerHTML = `
            <td>${echapperHtml(etudiant.da)}</td>
            <td>${echapperHtml(etudiant.prenom)}</td>
            <td>${echapperHtml(etudiant.nom)}</td>
            <td style="width: 80px;">${inputHeuresHTML}</td>
            <td>
                <input type="text"
                       class="controle-form input-notes"
                       id="notes_${etudiant.da}"
                       value="${echapperHtml(notes)}"
                       placeholder="Notes..."
                       ${estVerrouille ? 'disabled' : ''}>
            </td>
            <td><span id="heuresHisto_${etudiant.da}">${totalHeuresAvecSeanceActuelle.toFixed(1)}h</span></td>
            <td>
                <span id="taux_${etudiant.da}" style="font-weight: 500;">
                    ${tauxAssiduiteActuel}%
                </span>
            </td>`;

        tbody.appendChild(tr);
    });

    // Mettre √† jour le compteur
    const nbEtudiants = document.getElementById('nbEtudiantsPresences');
    if (nbEtudiants) {
        nbEtudiants.textContent = etudiantsFiltres.length;
    }

    // Mettre √† jour le titre de la colonne Pr√©sence avec bouton
    const colonnePresenceTitre = document.getElementById('colonneHeuresTitre');
    if (colonnePresenceTitre) {
        // Toujours afficher 2h peu importe la dur√©e r√©elle
        colonnePresenceTitre.innerHTML = `
            Pr√©sence
            <button class="btn-mini btn-tous-presents" 
                    onclick="tousPresents()" 
                    ${estVerrouille ? 'disabled' : ''}
                    title="Mettre tous pr√©sents">
                Tous 2h
            </button>
            <button class="btn-mini btn-reinit" 
                    onclick="reinitialiserSaisie()" 
                    ${estVerrouille ? 'disabled' : ''}
                    title="R√©initialiser">
                ‚Üª
            </button>
        `;
    }

    // G√©rer l'√©tat des boutons principaux
    const btnTousPresents = document.getElementById('btn-tous-presents');
    const btnReinit = document.getElementById('btn-reinit-saisie');
    const btnEnregistrer = document.querySelector('[onclick="enregistrerPresences()"]');

    if (btnTousPresents) btnTousPresents.disabled = estVerrouille;
    if (btnReinit) btnReinit.disabled = estVerrouille;
    if (btnEnregistrer) btnEnregistrer.disabled = estVerrouille;
    calculerEtSauvegarderIndicesAssiduite();

    // Mettre √† jour le compteur pr√©sents/absents
    mettreAJourCompteurPresences();
}

/**
 * Obtient la classe CSS pour la saisie selon la valeur
 */
function obtenirClasseSaisie(heures, dureeMax, estFacultatif = false) {
    const valeur = parseFloat(heures) || 0;

    if (valeur === 0) {
        // Si c'est une absence facultative, utiliser une classe diff√©rente (couleur ambre)
        return estFacultatif ? 'saisie-absence-motivee' : 'saisie-absence';
    } else if (valeur < dureeMax) {
        return 'saisie-retard';
    } else if (valeur === dureeMax) {
        return 'saisie-present';
    }
    return 'saisie-vide';
}

/**
 * Applique le code couleur √† un input
 */
function appliquerCodeCouleurSaisie(inputHeures, dureeMax) {
    if (!inputHeures) return;

    const valeur = parseFloat(inputHeures.value) || 0;

    // Retirer toutes les classes (incluant saisie-absence-motivee)
    inputHeures.classList.remove('saisie-absence', 'saisie-absence-motivee', 'saisie-retard', 'saisie-present', 'saisie-vide');

    // Appliquer la bonne classe
    if (valeur === 0) {
        inputHeures.classList.add('saisie-absence');
    } else if (valeur < dureeMax) {
        inputHeures.classList.add('saisie-retard');
    } else if (valeur === dureeMax) {
        inputHeures.classList.add('saisie-present');
    } else {
        inputHeures.classList.add('saisie-vide');
    }
}

/**
 * Met √† jour les statistiques d'une ligne
 */
function mettreAJourLigne(da, dateStr) {
    const inputHeures = document.getElementById(`heures_${da}`);
    const spanTaux = document.getElementById(`taux_${da}`);
    const spanHeuresHisto = document.getElementById(`heuresHisto_${da}`);

    if (!inputHeures || !spanTaux) return;

    const heuresSeance = parseFloat(inputHeures.value) || 0;
    const dureeMax = obtenirHeuresSeance(dateStr);

    // Appliquer le code couleur
    appliquerCodeCouleurSaisie(inputHeures, dureeMax);

    // Mettre √† jour le total des heures (historique + s√©ance actuelle)
    if (spanHeuresHisto) {
        const heuresHistorique = calculerTotalHeuresPresence(da, dateStr);
        const totalHeuresAvecSeanceActuelle = heuresHistorique + heuresSeance;
        spanHeuresHisto.textContent = totalHeuresAvecSeanceActuelle.toFixed(1) + 'h';
    }

    // Mettre √† jour le taux
    const tauxAssiduiteActuel = calculerTauxAssiduite(da, dateStr, heuresSeance);

    spanTaux.textContent = tauxAssiduiteActuel + '%';
    // Format simple et uniforme pour tous
    spanTaux.style.fontWeight = '500';

    // Mettre √† jour le compteur pr√©sents/absents
    mettreAJourCompteurPresences();
}

/* ===============================
   ENREGISTREMENT
   =============================== */

/**
 * Enregistre les pr√©sences saisies
 */
function enregistrerPresences() {
    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) {
        alert('Veuillez s√©lectionner une date');
        return;
    }

    const dateStr = dateInput.value;
    const validation = validerDateSaisie(dateStr);

    if (validation.verrouille) {
        alert('Cette date est verrouill√©e. D√©verrouillez-la d\'abord pour modifier les pr√©sences.');
        return;
    }

    const selectGroupe = document.getElementById('selectGroupePresences');
    const groupeFiltre = selectGroupe ? selectGroupe.value : '';

    const etudiants = obtenirDonneesSelonMode('groupeEtudiants');
    let presences = JSON.parse(localStorage.getItem('presences') || '[]');

    // Filtrer les √©tudiants si un groupe est s√©lectionn√©
    let etudiantsATraiter = etudiants;
    if (groupeFiltre) {
        etudiantsATraiter = etudiants.filter(e => e.groupe === groupeFiltre);
    }

    // IMPORTANT : Sauvegarder les flags facultatifs AVANT de supprimer les anciennes pr√©sences
    const flagsFacultatifs = {};
    presences.forEach(p => {
        if (p.date === dateStr && p.facultatif === true) {
            flagsFacultatifs[p.da] = true;
        }
    });

    // Supprimer les anciennes pr√©sences pour cette date et ces √©tudiants
    presences = presences.filter(p => {
        if (p.date !== dateStr) return true;
        return !etudiantsATraiter.some(e => e.da === p.da);
    });

    // Ajouter les nouvelles pr√©sences
    etudiantsATraiter.forEach(etudiant => {
        const inputHeures = document.getElementById(`heures_${etudiant.da}`);
        const inputNotes = document.getElementById(`notes_${etudiant.da}`);

        if (inputHeures) {
            const heures = parseFloat(inputHeures.value) || 0;
            const notes = inputNotes ? inputNotes.value.trim() : '';

            // Cr√©er l'objet de pr√©sence
            const presenceObj = {
                date: dateStr,
                da: etudiant.da,
                heures: heures,
                notes: notes
            };

            // IMPORTANT : Pr√©server le flag facultatif s'il existait
            if (flagsFacultatifs[etudiant.da] === true) {
                presenceObj.facultatif = true;
            }

            presences.push(presenceObj);
        }
    });

    // Protection : bloquer en mode anonymisation, rediriger en mode simulation
    if (!sauvegarderDonneesSelonMode('presences', presences)) {
        afficherNotificationErreur('Modification impossible', 'Impossible de sauvegarder les pr√©sences en mode anonymisation');
        return;
    }

    // Notification visuelle
    const message = document.createElement('div');
    message.className = 'notification notification-succes';
    message.innerHTML = '‚úÖ Pr√©sences enregistr√©es avec succ√®s';
    message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #d4edda;
        color: #155724;
        padding: 12px 20px;
        border-radius: 6px;
        border: 1px solid #c3e6cb;
        z-index: 9999;
        animation: slideIn 0.3s ease;
    `;
    document.body.appendChild(message);

    setTimeout(() => message.remove(), 3000);

    console.log(`‚úÖ Pr√©sences enregistr√©es pour le ${dateStr}`);
    calculerEtSauvegarderIndicesAssiduite();

    // ========== NOUVEAU : Recharger le tableau de bord ==========
    // Si le tableau de bord est visible, le rafra√Æchir
    const sectionTableauBord = document.getElementById('tableau-bord');
    if (sectionTableauBord && sectionTableauBord.classList.contains('active')) {
        console.log('üîÑ Rafra√Æchissement du tableau de bord apr√®s saisie...');

        // Recharger l'aper√ßu si c'est la sous-section active
        const apercu = document.getElementById('tableau-bord-apercu');
        if (apercu && apercu.classList.contains('active')) {
            if (typeof chargerTableauBordApercu === 'function') {
                setTimeout(() => chargerTableauBordApercu(), 300);
            }
        }
    }

    console.log(`‚úÖ Pr√©sences enregistr√©es pour le ${dateStr}`);
}

/* ===============================
   üßÆ CALCULS STATISTIQUES
   =============================== */

/**
 * Calcule le total des heures de pr√©sence d'un √©tudiant
 */
function calculerTotalHeuresPresence(da, dateActuelle) {
    // IMPORTANT : Utiliser obtenirDonneesSelonMode pour respecter le mode actuel
    const presences = obtenirDonneesSelonMode('presences') || [];

    return presences
        .filter(p => p.da === da && (dateActuelle === null || p.date < dateActuelle))
        .reduce((total, p) => total + (p.heures || 0), 0);
}

/**
 * Calcule le taux d'assiduit√© d'un √©tudiant
 */
function calculerTauxAssiduite(da, dateActuelle, heuresSeanceActuelle) {
    // Utiliser les indices sauvegard√©s qui tiennent compte des s√©ances facultatives
    const indices = JSON.parse(localStorage.getItem('indicesAssiduite') || '{}');

    if (indices.sommatif && indices.sommatif[da] !== undefined) {
        // Retourner l'indice sommatif sauvegard√© (d√©j√† calcul√© avec logique facultative)
        // IMPORTANT: indices.sommatif[da] est maintenant un objet {indice, heuresPresentes, heuresOffertes, nombreSeances}
        const assiduiteSommatif = indices.sommatif[da];
        const indice = (typeof assiduiteSommatif === 'object') ? assiduiteSommatif.indice : assiduiteSommatif;
        const taux = indice * 100;
        return Math.min(Math.round(taux), 100);
    }

    // Fallback : ancienne logique si les indices ne sont pas disponibles
    const nombreSeances = calculerNombreSeances(dateActuelle);

    if (nombreSeances === 0) {
        return 100; // Pas encore de cours, donc 100%
    }

    const dureeSeance = obtenirDureeMaxSeance();
    const heuresTheoriques = nombreSeances * dureeSeance;

    if (heuresTheoriques === 0) {
        return 100;
    }

    const heuresHistorique = calculerTotalHeuresPresence(da, dateActuelle);
    const heuresReelles = heuresHistorique + heuresSeanceActuelle;

    const taux = (heuresReelles / heuresTheoriques) * 100;
    return Math.min(Math.round(taux), 100);
}

/**
 * Obtient la classe CSS selon le taux d'assiduit√©
 * VERSION SIMPLIFI√âE - Sans badges, juste les couleurs
 */
function obtenirClasseTaux(taux) {
    if (taux >= 95) return 'taux-excellent';
    if (taux >= 85) return 'taux-bon';
    if (taux >= 75) return 'taux-moyen';
    if (taux >= 65) return 'taux-faible';
    return 'taux-critique';
}

/* ===============================
   üîÑ ACTIONS RAPIDES
   =============================== */

/**
 * Met tous les √©tudiants pr√©sents (heures compl√®tes)
 * IMPORTANT : Pr√©serve les absences motiv√©es R√†I (0h avec facultatif=true)
 */
function tousPresents() {
    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) return;

    const dateStr = dateInput.value;
    const dureeSeance = obtenirHeuresSeance(dateStr);
    const inputs = document.querySelectorAll('.input-heures');

    // Obtenir les pr√©sences existantes pour cette date
    const presences = obtenirDonneesSelonMode('presences') || [];

    let nbMisPresents = 0;
    let nbAbsencesMotiveesPreservees = 0;

    inputs.forEach(input => {
        if (!input.disabled) {
            const da = input.id.replace('heures_', '');

            // V√©rifier si cet √©tudiant a une absence motiv√©e R√†I
            const presenceExistante = presences.find(p => p.date === dateStr && p.da === da);
            const estAbsenceMotivee = presenceExistante &&
                                      presenceExistante.facultatif === true &&
                                      presenceExistante.heures === 0;

            if (estAbsenceMotivee) {
                // Ne pas toucher aux absences motiv√©es R√†I
                console.log(`   ‚ö™ ${da}: Absence motiv√©e R√†I pr√©serv√©e (0h)`);
                nbAbsencesMotiveesPreservees++;
            } else {
                // Mettre pr√©sent
                input.value = dureeSeance;

                // Appliquer le code couleur
                appliquerCodeCouleurSaisie(input, dureeSeance);

                // Mettre √† jour les stats
                mettreAJourLigne(da, dateStr);

                nbMisPresents++;
            }
        }
    });

    console.log(`‚úÖ ${nbMisPresents} √©tudiant(s) mis pr√©sents (${dureeSeance}h)`);
    if (nbAbsencesMotiveesPreservees > 0) {
        console.log(`   ‚ö™ ${nbAbsencesMotiveesPreservees} absence(s) motiv√©e(s) R√†I pr√©serv√©e(s)`);
    }
}

/**
 * R√©initialise la saisie (met toutes les heures √† 0)
 */
function reinitialiserSaisie() {
    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) return;

    const dureeSeance = obtenirHeuresSeance(dateInput.value);

    // Pas de confirmation pour √™tre plus rapide
    document.querySelectorAll('.input-heures').forEach(input => {
        if (!input.disabled) {
            input.value = 0;
            appliquerCodeCouleurSaisie(input, dureeSeance);

            const da = input.id.replace('heures_', '');
            mettreAJourLigne(da, dateInput.value);
        }
    });

    document.querySelectorAll('.input-notes').forEach(input => {
        if (!input.disabled) {
            input.value = '';
        }
    });

    console.log('‚úÖ Saisie r√©initialis√©e');
}

/* ===============================
   üîÄ NAVIGATION ENTRE DATES
   =============================== */

/**
 * Trouve la date du cours suivant
 */
function trouverCoursSuivant(dateActuelle) {
    const datesCours = obtenirToutesDatesCours();

    for (let i = 0; i < datesCours.length; i++) {
        if (datesCours[i] > dateActuelle) {
            return datesCours[i];
        }
    }

    return null;
}

/**
 * Trouve la date du cours pr√©c√©dent
 */
function trouverCoursPrecedent(dateActuelle) {
    const datesCours = obtenirToutesDatesCours();

    for (let i = datesCours.length - 1; i >= 0; i--) {
        if (datesCours[i] < dateActuelle) {
            return datesCours[i];
        }
    }

    return null;
}

/**
 * Navigate vers le cours suivant
 */
function allerCoursSuivant() {
    console.log('üîµ Navigation vers le cours suivant');

    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) {
        console.log('‚ùå Aucune date s√©lectionn√©e');
        return;
    }

    const dateActuelle = dateInput.value;
    const datesCours = obtenirToutesDatesCours();

    console.log(`Date actuelle: ${dateActuelle}`);
    console.log(`üìö Nombre total de dates de cours: ${datesCours.length}`);

    // Trouver le prochain cours apr√®s la date actuelle
    let coursSuivant = null;
    for (let i = 0; i < datesCours.length; i++) {
        if (datesCours[i] > dateActuelle) {
            coursSuivant = datesCours[i];
            console.log(`‚úÖ Prochain cours trouv√©: ${coursSuivant}`);
            break;
        }
    }

    if (coursSuivant) {
        dateInput.value = coursSuivant;
        initialiserSaisiePresences();
        mettreAJourBoutonsNavigation();
    } else {
        console.log('‚ö†Ô∏è Aucun cours suivant disponible');
    }
}

/**
 * Navigate vers le cours pr√©c√©dent
 */
function allerCoursPrecedent() {
    console.log('üîµ Navigation vers le cours pr√©c√©dent');

    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) {
        console.log('‚ùå Aucune date s√©lectionn√©e');
        return;
    }

    const dateActuelle = dateInput.value;
    const datesCours = obtenirToutesDatesCours();

    console.log(`Date actuelle: ${dateActuelle}`);
    console.log(`üìö Nombre total de dates de cours: ${datesCours.length}`);

    // Trouver le cours pr√©c√©dent avant la date actuelle
    let coursPrecedent = null;
    for (let i = datesCours.length - 1; i >= 0; i--) {
        if (datesCours[i] < dateActuelle) {
            coursPrecedent = datesCours[i];
            console.log(`‚úÖ Cours pr√©c√©dent trouv√©: ${coursPrecedent}`);
            break;
        }
    }

    if (coursPrecedent) {
        dateInput.value = coursPrecedent;
        initialiserSaisiePresences();
        mettreAJourBoutonsNavigation();
    } else {
        console.log('‚ö†Ô∏è Aucun cours pr√©c√©dent disponible');
    }
}

/**
 * Met √† jour l'√©tat des boutons de navigation
 */
function mettreAJourBoutonsNavigation() {
    const dateInput = document.getElementById('date-cours');
    if (!dateInput || !dateInput.value) {
        console.log('‚ö†Ô∏è Pas de date pour la navigation');
        return;
    }

    const btnPrecedent = document.querySelector('[onclick="allerCoursPrecedent()"]');
    const btnSuivant = document.querySelector('[onclick="allerCoursSuivant()"]');

    const coursPrecedent = trouverCoursPrecedent(dateInput.value);
    const coursSuivant = trouverCoursSuivant(dateInput.value);

    if (btnPrecedent) {
        btnPrecedent.disabled = !coursPrecedent;
        btnPrecedent.style.opacity = coursPrecedent ? '1' : '0.5';
        btnPrecedent.style.cursor = coursPrecedent ? 'pointer' : 'not-allowed';
        console.log('Bouton pr√©c√©dent:', coursPrecedent ? 'actif' : 'inactif');
    }

    if (btnSuivant) {
        btnSuivant.disabled = !coursSuivant;
        btnSuivant.style.opacity = coursSuivant ? '1' : '0.5';
        btnSuivant.style.cursor = coursSuivant ? 'pointer' : 'not-allowed';
        console.log('Bouton suivant:', coursSuivant ? 'actif' : 'inactif');
    }
}

/* ===============================
   UTILITAIRES
   =============================== */

/**
 * Formate une date en fran√ßais
 */
function formaterDateFrancais(dateStr) {
    const date = new Date(dateStr + 'T12:00:00');
    const options = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    return date.toLocaleDateString('fr-CA', options);
}

/**
 * √âchappe les caract√®res HTML
 */
function echapperHtml(str) {
    // V√©rifier si la fonction existe dans config.js
    if (window.echapperHtml && window.echapperHtml !== echapperHtml) {
        return window.echapperHtml(str);
    }

    const div = document.createElement('div');
    div.textContent = str || '';
    return div.innerHTML;
}

/**
 * Ouvre la saisie de pr√©sence depuis le calendrier
 */
function ouvrirSaisiePresence(date) {
    console.log('Ouverture saisie depuis calendrier pour:', date);

    // Naviguer vers la section pr√©sences
    if (typeof sectionActive !== 'undefined' && sectionActive !== 'presences') {
        if (typeof afficherSection === 'function') {
            afficherSection('presences');
        }
    }

    // Afficher la sous-section saisie
    if (typeof afficherSousSection === 'function') {
        afficherSousSection('presences-saisie');
    }

    // Mettre √† jour les boutons de navigation
    setTimeout(() => {
        const boutonsNav = document.querySelectorAll('.sous-navigation button');
        boutonsNav.forEach(btn => {
            btn.classList.remove('actif');
            if (btn.getAttribute('data-sous-onglet') === 'presences-saisie') {
                btn.classList.add('actif');
            }
        });

        // Pr√©-remplir la date
        const dateInput = document.getElementById('date-cours');
        if (dateInput) {
            dateInput.value = date;
            initialiserSaisiePresences();
            mettreAJourBoutonsNavigation();
        }
    }, 100);
}

/**
 * Obtient la derni√®re date de saisie (pour statistiques)
 */
function obtenirDerniereDataSaisie(da = null) {
    const presences = JSON.parse(localStorage.getItem('presences') || '[]');

    if (presences.length === 0) {
        return null;
    }

    let presencesFiltrees = presences;
    if (da) {
        presencesFiltrees = presences.filter(p =>
            p.da === da && p.heures !== null && p.heures !== undefined
        );
    }

    if (presencesFiltrees.length === 0) {
        return null;
    }

    const dates = presencesFiltrees.map(p => p.date);
    dates.sort();

    return dates[dates.length - 1];
}



/* ===============================
   üìå EXPORT GLOBAL ET LOGS
   =============================== */

// Rendre les fonctions disponibles globalement
window.initialiserModuleSaisiePresences = initialiserModuleSaisiePresences;
window.chargerGroupesPresences = chargerGroupesPresences;
window.initialiserSaisiePresences = initialiserSaisiePresences;
window.enregistrerPresences = enregistrerPresences;
/**
 * Filtre le tableau de saisie des pr√©sences selon la recherche
 */
function filtrerTableauPresences() {
    const recherche = document.getElementById('recherche-saisie-presences');
    if (!recherche) return;

    const terme = recherche.value.toLowerCase().trim();

    // Sauvegarder la valeur de recherche pour la persistance lors de la navigation
    localStorage.setItem('recherchePresences', terme);

    const tbody = document.getElementById('tbody-saisie-presences');
    if (!tbody) return;

    const lignes = tbody.getElementsByTagName('tr');

    for (let ligne of lignes) {
        // Ne pas filtrer la ligne de message "S√©lectionnez une date"
        if (ligne.cells.length < 3) {
            continue;
        }

        const da = ligne.cells[0]?.textContent.toLowerCase() || '';
        const prenom = ligne.cells[1]?.textContent.toLowerCase() || '';
        const nom = ligne.cells[2]?.textContent.toLowerCase() || '';

        if (terme === '' || da.includes(terme) || prenom.includes(terme) || nom.includes(terme)) {
            ligne.style.display = '';
        } else {
            ligne.style.display = 'none';
        }
    }

    // Mettre √† jour le compteur apr√®s filtrage
    mettreAJourCompteurPresences();
}

/**
 * Met √† jour le compteur de pr√©sents/absents en temps r√©el
 */
function mettreAJourCompteurPresences() {
    const tbody = document.getElementById('tbody-saisie-presences');
    if (!tbody) return;

    const lignes = tbody.getElementsByTagName('tr');
    let nbPresents = 0;
    let nbAbsents = 0;
    let nbTotal = 0;

    for (let ligne of lignes) {
        // Ignorer les lignes de message (pas assez de cellules)
        if (ligne.cells.length < 4) continue;

        // Ignorer les lignes cach√©es par le filtre de recherche
        if (ligne.style.display === 'none') continue;

        nbTotal++;

        // R√©cup√©rer le champ heures (4√®me cellule, index 3)
        const celluleHeures = ligne.cells[3];
        const inputHeures = celluleHeures?.querySelector('input[type="number"]');

        if (inputHeures) {
            const heures = parseFloat(inputHeures.value) || 0;
            if (heures > 0) {
                nbPresents++;
            } else {
                nbAbsents++;
            }
        }
    }

    // Calculer l'assiduit√© aujourd'hui
    const tauxAssiduiteAujourdhui = nbTotal > 0 ? Math.round((nbPresents / nbTotal) * 100) : 0;

    // Mettre √† jour les compteurs dans le DOM
    const spanPresents = document.getElementById('nb-presents');
    const spanAbsents = document.getElementById('nb-absents');
    const spanTotal = document.getElementById('nb-total');
    const spanAssiduiteAujourdhui = document.getElementById('assiduite-aujourdhui');

    if (spanPresents) spanPresents.textContent = nbPresents;
    if (spanAbsents) spanAbsents.textContent = nbAbsents;
    if (spanTotal) spanTotal.textContent = nbTotal;
    if (spanAssiduiteAujourdhui) spanAssiduiteAujourdhui.textContent = tauxAssiduiteAujourdhui + '%';
}

window.tousPresents = tousPresents;
window.reinitialiserSaisie = reinitialiserSaisie;
window.allerCoursSuivant = allerCoursSuivant;
window.allerCoursPrecedent = allerCoursPrecedent;
window.basculerVerrouillageDate = basculerVerrouillageDate;
window.ouvrirSaisiePresence = ouvrirSaisiePresence;
window.mettreAJourLigne = mettreAJourLigne;
window.appliquerCodeCouleurSaisie = appliquerCodeCouleurSaisie;
window.filtrerTableauPresences = filtrerTableauPresences;

/* ===============================
   üîÑ RECHARGEMENT AUTOMATIQUE
   =============================== */

/**
 * Surveille l'activation de la sous-section 'presences-saisie'
 * et recharge automatiquement le tableau pour refl√©ter les changements
 * faits depuis d'autres sections (ex: modifications d'interventions R√†I)
 */
document.addEventListener('DOMContentLoaded', function() {
    const sectionSaisie = document.getElementById('presences-saisie');
    if (!sectionSaisie) return;

    // Observer les changements de la classe 'active' sur la sous-section
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                // Si la sous-section vient de devenir active
                if (sectionSaisie.classList.contains('active')) {
                    const dateInput = document.getElementById('date-cours');
                    if (dateInput && dateInput.value) {
                        console.log('üîÑ Rechargement automatique du tableau de pr√©sences');
                        initialiserSaisiePresences();
                    }
                }
            }
        });
    });

    // Commencer √† observer
    observer.observe(sectionSaisie, {
        attributes: true,
        attributeFilter: ['class']
    });

    console.log('‚úÖ Observer de rechargement automatique activ√© pour presences-saisie');
});

console.log('‚úÖ Module saisie-presences.js charg√© (version refond√©e compl√®te)');